Note. 以下问题都基于64bit环境

## 1. OC对象的本质

OC的对象、类，主要是基于C\C++的结构体实现的

> 将OC代码转换为C\C++代码：

````c
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件
````

如果需要链接其他框架，使用-framework参数，比如：-framework UIKit

### 001、一个NSObject对象占用多少内存？

* 系统分配了16个字节给NSObject对象（通过`malloc_size`函数获得）
* 但是NSObject对象内部只使用了8个字节的空间（通过`class_getInstanceSize`函数获得）。

> 源码分析如下：  
> 
> * 关于`class_getInstanceSize`函数，实际上是获取类的成员变量占用的内存大小（指针大小的倍数，向上取整，其实就是内存对齐后的大小）；
* 关于`malloc_size`函数，其获取的是类的实例对象所占用的内存大小，即类在`alloc`时系统分配的内存大小；
	* `alloc`底层调用的是`_class_createInstanceFromZone`函数，该函数通过`cls->instanceSize`获取类的size，而`instanceSize`对size做了额外处理：如果`size < 16`，令`size = 16`。也就是说，类在`alloc`时，系统会为其分配至少`16个字节`的内存。

sizeof(类型)：不是函数，是个运算符，编译期编译时就计算好了。（可以类比`#define`）

### 002、一个OC对象在内存中是如何布局的？

````
struct NSObject_IMPL {
	Class isa;
}

struct Persion_IMPL {
	struct NSObject_IMPL Student_IVARS;
	int _age;
}

struct Student_IMPL {
	struct Persion_IMPL Persion_IVARS;
	int _age;
}
````

* 内存的大端、小端模式  
* x/4xg：读取内存/4 16进制 8字节
* 内存对齐：结构体的最终内存大小，必须是最大成员大小的倍数

### 003、alloc内存分配

````c
@interface Person : NSObject
{
    int _no;        // 4
    int _age;       // 4
    int _height;    // 4
}// 8 + 12 = 20，实际是24（class_getInstanceSize([Person class])）

@end

@implementation Person

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"%zd", class_getInstanceSize([Person class]));        // 24
        NSLog(@"%zd", malloc_size((__bridge void *)[Person alloc])); // 32
    }
    return 0;
}
````	
> 说明：
> 
> 1. `alloc`时，获取`size`（此时，通过结构体内存对齐计算得出，同时OC又做了最少16字节的调整）
> 2. 向系统申请内存，此时再次进行`内存对齐`（与`1`中的对齐不一样，iOS系统做了限制，内存分配是16的倍数）：
> 	* `buckets size`：{16, 32, 48, 64, 80, 96, 112, ... , 256}
> 	* 有好几种`malloc`方式：如`malloc.c`、`nano_malloc.c`、`magazine_malloc.c`等等

### 004、OC对象的分类

* instance对象（实例对象）：通过类alloc出来的对象
	* 只存储成员变量（`isa`、其他成员变量）
	
> 特点：`isa`是第一个成员变量，因此`isa`的地址也就是实例对象的地址。

* class对象（类对象），其存储了：
	* isa指针
	* superClass指针
	* 类的属性信息（@property）
	* 类的对象方法信息（instance method） 
	* 类的协议信息（protocol）
	* 类的成员变量信息（ivar）：描述信息，即类型、名称，不是成员变量的值（值由实例对象决定）
	* ...

> * 一个类的类对象在内存中只有一份！

可通过以下方法获取类对象

````c
NSObject *obj = [[NSObject alloc] init];
Class c1 = [obj class];
Class c2 = object_getClass(obj);
Class c3 = [NSObject class];
````

* meta-class对象（元类对象），元类对象 和 类对象 的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：
	* isa指针
	* superClass指针
	* 类的类方法信息（class method）
	* 有但不存储（null）：类的属性、对象方法信息、协议信息、成员变量信息
	* ...
	
> * 每个类有且只有一个元类对象

其相关操作方法：

````c
// 获取元类对象
Class c1 = object_getClass([NSObject class]); // 传入类对象，可获得元类对象

// 查看是否为meta-class对象
BOOL result = class_isMetaClass([NSObject class]); // NO
````

### 005、对象的isa指针指向哪里

![img_isa](../images/img_isa.png)

1. 问：对象的isa指针指向哪里？
	* `instance对象（实例对象）`的isa指向`class对象（类对象）`
	* `class对象（类对象）`的isa指向`meta-class对象（元类对象）`
	* `meta-class对象（元类对象）`的isa指向`基类的meta-class对象（元类对象）`
2. 问：OC的类信息存放在哪里
	* 对象方法、属性、成员变量、协议信息，存放在`class对象（类对象）`；
	* 类方法，存放在`meta-class对象（元类对象）`；
	* 成员变量的具体指，存放在`instance对象（实例对象）`

## 2. KVO

**KVO：Key-Value Observing 键值监听**

````c
// 假设对person对象age进行KVO
Person *person = [[Person alloc] init];
...
````

### 006、iOS用什么方式实现对一个对象的KVO？（即KVO的本质是什么？）

其本质是：

1. （利用OC的RuntimeAPI）运行时动态创建 `NSKVONotifying_Person类`（同时也创建了`NSKVONotifying_Person元类`）：
	* 该类的 `superClass` 是 `Person类`；
	* `person对象` 的 `isa` 指向该类；
	* 重写添加监听属性的setter方法（令其IMP指向Foundation框架的`_NSSetXXXValueAndNotify`函数），
	* 该类还创建了`-class`、`-dealloc`、`-isKVOA`三个方法
2. 当修改实例对象的属性时，会调用Foundation框架的`_NSSetXXXValueAndNotify`函数，该函数的伪代码如下：
	* 首先调用`-willChangeValueForKey:`
	* 然后调用父类的setter方法
	* 最后调用`-didChangeValueForKey:`
		* 此方法内部会触发监听器（Observer）的监听方法（observeValueFoeKeyPath:ofObject:change:context:）

> 值得注意的是：
> 
> * `object_getClass(person);` 返回的是 `NSKVONotifying_Person类`
> * `[person class];` 返回的仍然是 `Person类`

那么，为何要重写`-class`方法呢？

如果不重写，将返回`NSKVONotifying_Person类`，重写后返回的是`Person类`。由此，**猜测是要屏蔽内部实现，隐藏`NSKVONotifying_Person类`。**

> 关于`_NSSetIntValueAndNotify`函数的说明，该函数是Foundation框架中的，用于setInt，类似的还有setChar、setDouble、setLong、setObject、setRect等等

### 007、如何手动触发KVO？

如下：

````c
[self.person willChangeValueForKey:@"age"];
[self.person didChangeValueForKey:@"age"];
````

### 008、直接修改成员变量会不会触发KVO？为什么？

不会！因为KVO的本质是修改了属性的setter方法（令其IMP指向Foundation框架的`_NSSetXXXValueAndNotify`函数），而直接修改成员变量没有调用setter方法。

## 3、KVC

**KVC：Key-Value Coding 键值编码**，可以通过一个key来访问某个属性

常见的API：

* -setValue:forKey:
* -setValue:forKeyPath:
* -getValueForKey:
* -getValueForKeyPath:

### 009、通过KVC修改属性会触发KVO吗？

会触发！

### 010、KVC的赋值和取值过程是怎样的？原理是什么？

* setter：

![img_kvc_setter](../images/img_kvc_setter.png)

* getter：

![img_kvc_getter](../images/img_kvc_getter.png)

## 4、Category

### 011、Category的实现原理

### 012、Category和Extension的区别是什么？

### 013、Category中有load方法吗？load方法时什么时候调用的？load方法能继承吗？

### 014、load、initialize方法的区别是什么？它们在Category中的调用顺序？以及出现继承时它们之间的调用过程？

### 015、Category能否添加成员变量？如果可以，如何给Category添加成员变量？